// Generated by CoffeeScript 1.6.3
(function() {
  var LT, VERSION, attach, attachedTabs, detach, evalJs, getFile, initSocket, isScriptMatch, onAttach, onDetach, onEvent, onScriptParsed, resetTarget,
    __indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

  attachedTabs = {};

  VERSION = "1.0";

  LT = {
    host: "http://localhost",
    port: null,
    socket: null
  };

  window.LT = LT;

  chrome.runtime.onConnect.addListener(function(port) {
    if (port.name === "lttools") {
      return port.onMessage.addListener(function(msg) {
        console.log(msg);
        return LT.socket.emit("result", [void 0, "clients.raise-on-object", msg.data]);
      });
    }
  });

  isScriptMatch = function(script, filename) {
    if (script.filename.match(/\(old\)$/)) {
      return false;
    }
    return script.filename === filename || __indexOf.call(script.sources, filename) >= 0;
  };

  evalJs = function(target, message) {
    var cb, client, code, command, filename, highest, i, length, matchingScript, meta, name, params, parts, path, pos, s, script, scripts, str, tabId, tabScripts, _i, _j, _len, _len1, _ref, _ref1;
    tabId = target.tabId;
    client = message[0], command = message[1], (_ref = message[2], name = _ref.name, path = _ref.path, pos = _ref.pos, code = _ref.code, meta = _ref.meta);
    filename = name != null ? name.toLowerCase() : void 0;
    tabScripts = attachedTabs[tabId].scripts;
    scripts = (function() {
      var _i, _len, _results;
      _results = [];
      for (_i = 0, _len = tabScripts.length; _i < _len; _i++) {
        s = tabScripts[_i];
        if (isScriptMatch(s, filename)) {
          _results.push(s);
        }
      }
      return _results;
    })();
    if (scripts.length > 0) {
      matchingScript = scripts[0];
    }
    if (scripts.length > 1) {
      parts = path.toLowerCase().replace("/" + filename, '').split('/').reverse();
      highest = -1;
      for (_i = 0, _len = scripts.length; _i < _len; _i++) {
        script = scripts[_i];
        length = 0;
        _ref1 = script.directory.replace(/\/$/, '').split('/').reverse();
        for (i = _j = 0, _len1 = _ref1.length; _j < _len1; i = ++_j) {
          str = _ref1[i];
          if (str !== parts[i]) {
            break;
          } else {
            length = length + 1;
          }
        }
        if (length > highest) {
          highest = length;
          matchingScript = script;
        }
      }
    }
    cb = function(data) {
      var result, returnData;
      data || (data = {});
      result = data.result;
      meta || (meta = {});
      meta.type = result != null ? result.type : void 0;
      if (data.wasThrown) {
        command = "editor.eval.js.exception";
        returnData = {
          ex: result != null ? result.description : void 0,
          meta: meta
        };
      } else {
        command = "editor.eval.js.result";
        returnData = {
          result: JSON.stringify(result != null ? result.value : void 0),
          meta: meta,
          "no-inspect": true
        };
      }
      return LT.socket.emit("result", [client, command, returnData]);
    };
    if (meta || !matchingScript) {
      command = "Runtime.evaluate";
      params = {
        expression: code,
        returnByValue: true
      };
    } else {
      command = "Debugger.setScriptSource";
      params = {
        scriptId: matchingScript.scriptId,
        scriptSource: code
      };
    }
    return chrome["debugger"].sendCommand(target, command, params, cb);
  };

  initSocket = function(target, cb) {
    var errorCb, onConnect, socket, _ref, _ref1;
    if ((_ref = LT.socket) != null ? (_ref1 = _ref.socket) != null ? _ref1.connected : void 0 : void 0) {
      return cb();
    } else if (LT.socket) {
      LT.socket.socket.options.port = LT.port.toString();
      return LT.socket.socket.reconnect();
    } else {
      LT.socket = socket = io.connect(LT.host + ':' + LT.port.toString());
      errorCb = function() {
        LT.port = null;
        return alert("Could not connect - do you have the right port?");
      };
      socket.on("connect_failed", errorCb);
      socket.on("error", errorCb);
      socket.on("client.close", function() {
        return socket.disconnect();
      });
      socket.on("disconnect", function() {
        var tabId, _, _results;
        console.log("disconnect");
        _results = [];
        for (tabId in attachedTabs) {
          _ = attachedTabs[tabId];
          _results.push(detach({
            tabId: parseInt(tabId)
          }));
        }
        return _results;
      });
      socket.on("reconnect", function() {
        return console.log("io.reconnect");
      });
      socket.on("reconnecting", function() {
        return console.log("io.reconnecting");
      });
      socket.on("reconnect_failed", function() {
        return console.log("io.reconnect_failed");
      });
      socket.on("editor.eval.js", function(message) {
        return evalJs(target, message);
      });
      onConnect = function() {
        cb();
        return socket.emit("init", {
          name: window.location.host || window.title || window.location.href,
          types: ["js", "css", "html"],
          commands: ["editor.eval.js", "editor.eval.cljs.exec", "editor.eval.html", "editor.eval.css"]
        });
      };
      return socket.on("connect", onConnect);
    }
  };

  onAttach = function(target) {
    var tabId;
    tabId = target.tabId;
    chrome.browserAction.setIcon({
      tabId: tabId,
      path: "connected.png"
    });
    chrome.browserAction.setTitle({
      tabId: tabId,
      title: "Disconnect from LT"
    });
    return chrome.tabs.executeScript(null, {
      file: "lttools.js"
    });
  };

  detach = function(target) {
    if (LT.socket) {
      LT.socket.disconnect();
    }
    return chrome["debugger"].detach(target, function() {
      return onDetach(target);
    });
  };

  attach = function(target) {
    var onDebuggerEnabled, _name;
    attachedTabs[_name = target.tabId] || (attachedTabs[_name] = {
      scripts: [],
      scriptIds: []
    });
    attachedTabs[target.tabId].status = "attaching";
    chrome["debugger"].attach(target, VERSION, function() {
      return onAttach(target);
    });
    chrome["debugger"].sendCommand(target, "Console.enable", {});
    chrome["debugger"].sendCommand(target, "Runtime.enable", {}, function() {
      return null;
      /* Prototype for angularjs watcheres
      chrome.debugger.sendCommand target, "Runtime.evaluate", {
        expression: """window.lttools = {
            watch: function(data) {
              var opts, parts, scopeName;
              console.log(this);
              parts = data.expression.split(".");
              scopeName = parts.shift();
              opts = data.opts;
              this.$watch(parts.join('.'), function (a) { console.log(a); window.postMessage({action: 'lttools.watch', params: { expression: a, opts: opts}}, '*'); }, true);
            }
          };
      """
      }
      */

    });
    onDebuggerEnabled = function() {
      return attachedTabs[target.tabId].status = "enabled";
    };
    return chrome["debugger"].sendCommand(target, "Debugger.enable", {}, onDebuggerEnabled);
  };

  getFile = function(url, listener) {
    var oReq;
    oReq = new XMLHttpRequest();
    oReq.onload = listener;
    oReq.open("get", url, true);
    return oReq.send();
  };

  chrome.browserAction.onClicked.addListener(function(tab) {
    var onInit, target, _ref, _ref1;
    if (!LT.port || ((_ref = LT.socket) != null ? (_ref1 = _ref.socket) != null ? _ref1.reconnecting : void 0 : void 0)) {
      LT.port = prompt("WebSocket Port (in LT Add Connection -> Ports): ", LT.port);
    }
    target = {
      tabId: tab.id
    };
    onInit = function() {
      var status, _ref2;
      status = (_ref2 = attachedTabs[target.tabId]) != null ? _ref2.status : void 0;
      if (status === "attaching") {
        return;
      }
      if (status === "enabled") {
        return detach(target);
      } else {
        return attach(target);
      }
    };
    return initSocket(target, onInit);
  });

  onDetach = function(target) {
    var tabId;
    tabId = target.tabId;
    attachedTabs[tabId].status = "detached";
    chrome.browserAction.setIcon({
      tabId: tabId,
      path: "disconnected.png"
    });
    return chrome.browserAction.setTitle({
      tabId: tabId,
      title: "Connect to LT"
    });
  };

  onScriptParsed = function(target, params) {
    var baseUrl, filename, hostname, isContentScript, matches, matchingScriptId, parts, path, script, scriptData, scriptId, sourceMapURL, tabId, url, _, _i, _len;
    tabId = target.tabId;
    isContentScript = params.isContentScript, scriptId = params.scriptId, url = params.url, sourceMapURL = params.sourceMapURL;
    if (isContentScript) {
      return;
    }
    path = url;
    if (matches = url.match(/(http(s)?:\/\/([^/]*\/)|file:\/\/)(.*$)/)) {
      _ = matches[0], _ = matches[1], _ = matches[2], hostname = matches[3], path = matches[4];
    }
    parts = url.split('/');
    filename = parts.pop().toLowerCase();
    baseUrl = parts.join('/');
    scriptData = {
      path: path,
      directory: path.toLowerCase().replace(filename, ''),
      filename: filename,
      scriptId: scriptId,
      url: url,
      sources: []
    };
    for (_i = 0, _len = scriptData.length; _i < _len; _i++) {
      script = scriptData[_i];
      if (script.scriptId === scriptId) {
        matchingScriptId = script.scriptId;
      }
    }
    if (sourceMapURL) {
      getFile(baseUrl + '/' + sourceMapURL, function() {
        var e, sourceMap;
        if (this.status !== 200) {
          return;
        }
        try {
          sourceMap = JSON.parse(this.response);
          return scriptData.sources = sourceMap.sources;
        } catch (_error) {
          e = _error;
          return console.log("Failed to parse source map", e);
        }
      });
    }
    attachedTabs[tabId].scripts.push(scriptData);
    return attachedTabs[tabId].scriptIds.push(scriptId);
  };

  resetTarget = function(target) {
    attachedTabs[target.tabId].scripts = [];
    return attachedTabs[target.tabId].scriptIds = [];
  };

  onEvent = function(target, method, params) {
    switch (method) {
      case "Debugger.scriptParsed":
        return onScriptParsed(target, params);
      case "Debugger.globalObjectCleared":
        return resetTarget(target);
      case "Console.messageAdded":
        return null;
      default:
        return console.log(method);
    }
  };

  chrome["debugger"].onEvent.addListener(onEvent);

  chrome["debugger"].onDetach.addListener(onDetach);

}).call(this);

/*
//@ sourceMappingURL=background.map
*/
